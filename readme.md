#FMVC


В сегодняшнем мире существует большое количество фреймверков,
позволяющих разработчикам реализовывать сложные веб приложения с минимальными усилиями.

#*AngularJS* - любимый многими фреймверк от Google,
предоставляющий декларативный подход к описанию шаблонов и возможность просто управлять данными с помощью пространств.
Плюсы:
полноценный фреймверк, обширный АПИ дает все необходимые инструменты для программиста,
декларативный подход и двунаправленное упрощает создание простых приложений и компонентов,
удобное использование JQuery плагинов в системе Angular.

К недостаткам (версии 1.x) можно отнести тяжелый рендеринг при изменении данных (клиентская производительность),
объемную доменную логику в API директив, при создании выражений вынесение бизнес логики в шаблоны.

#*ReactJS* - молодой и захватывающий популярность фреймверк от Facebook,
дающий возможность быстро и эффективно создавать компоненты отображения данных.

Плюсы:
Изоморфность,
Shadow dom, хранение в виртуальном дереве компонентов, точечные изменения.
Собственная система трансляция событий, обработчики только в виртуальном дереве, нет необходимости подписок.
Очень простой в начале, фактически отсутсвует доменная логика, позволяет использовать javascript в шаблонах.
Функциональный подход, внутренне и внешнее состояние компонента.
Использование последних новшесты ES6,
Компоненты: material design и другие.

Минусы ReactJS -
Отвечает только за отображение, для всего остального потребуются сторнние дополнительные библиотеки:
Для создания бизнес логики и взаимодействия компонентов - Flux, Redux; для роутинга, для взаимодействия с сервером,
а также сложные компоненты UI.

##Введение FMVC

Fastmvc - *Фреймверк, написанный на TypeScript, скомплированный в JavaScript,
реализующий модель MVC(c элементами VM) для взаимодействия данных их отображения.

Нацелен на использования в рамках вебкомпонентов и одностраничных приложений.*

Зависимости: underscore.js.

*Facade* - фасад приложения, объединяющий компоненты модели (данные, наборы данных) в единое пространство,
а также медиаторов, которые отвечают за создание элементов представления и связывание отображения с моделями и фасадом.

*Model* - в простейшем приближении это контейнер данных, которые отслеживает изменения в данных и оповещает подписчиков об изменениях.

*Mediator* - создает и связывает представления с соотвествующими моделями и фасадом.

*View* - представления, реализующие или V концепцию - события транслируются по дереву комонентов в ближайший медиатор и MVVM концепцию - события напрямую транслируются в модель.
Отображения могут быть связаны с моделью, в данном случае создадутся необходимые связи с моделью и компонент будет

##Fast templates

*Позволяют реализовать паттерн "PVM"*
Presentation - обработка входящих данных и их адоптация, например l18n, для представленя
VM - прямой биндинг изменений представлений в модели, через систему обработчиков событий

*Состояние*
Имеют внутреннее состояния (states), на основе которых происходит их рендеринг

*Внешние данные*
Работа как с чистыми данными, так и с моделями, для которых отслеживаются изменения - однонаправленный биндинг
Возможность использовать двусторонний биндинг.
Шаблоны отслеживают изменения используемых полей объектов, и при их изменении, обновляют точечно узлы DOM.

*Система выражений и деклараций*
Возможность описывать в шаблонах связи с данными и состояниями, использовать JavaScript выражения.

*Shadow dom*
Темплейты имеют shadow dom, все применяемые изменения точные, с минимальными прерисовками

*Собственная система диспетчеризации событий*
События браузера транслируются во внутренние события, которые распространяются по Shadow Dom дереву.
Фактически внутри стоит один обработчик на рутовом объекте (window)

*Расширенная система работы с классами элемента внутри шаблона*

*Поддержка и инкапсуляция стилей компонентов*

*Поддержка словарей*

Шаблоны описываются в html подобной разметкой,
в процессе обработки они пробразуются в JavaScript объекты,
наследующие базовый класс TemplateView.

```html
<div
      stateHandlers='hover,selected,disable'
      class='button button-{state.selected} button-{state.disabled}'
      onclick='myEvent'
      style="top:{state.top}px;left:{state.left}px;"
      >{data}
</div>
```

##Описание шаблона компонента:

Шаблоны могут содержать

Стандартный html синтаксис, со статическими аттрибутами:
<input placeholder='Ваше имя' value='Вася' />

Синтаксис, со динамическими аттрибутами:
<input placeholder='{state.placeholder}' value='{data.name}' />

Синтаксис, с динамическими выражениями:
<div>{(data.age>=30?'Здравствуйте':'Здравствуй')} {data.name}</div>

Синтаксис, со статическими параметрами компонента:
<div state.selected='true'></div>

Синтаксис, с динамическими параметрами компонента:
<div state.selected='{data.selected}'></div>

Параметры компонентов:

Установка и валидация состояний статических и динамичесих
state.*
state.selected="true"
state.selected="{data}"
state.selected="{(!data.phone}"

Установка автоматических обработчиков событий пользователя
.stateHandlers="hover,selected"

Работа с дата-провайдерами для произвольных узлов:
children.data
children.class

Выражения
#Expressions

Данные использующиеся в html контексте:

{data},{data.age},{data.image.href} - Возвращение полей данных произвольной глубины
{data.age|convertToRussianAge|wrapBrackets} - Возвращение данных с фильтрами
{data.name as NAME, data.age as AGE|i18n.age} - Возвращение комплексных данных через словари*
{(data.age>30?'больше 30':'меньше 30')} - Возвращение результата простых выражений со связанными данными

Данные которые используются в параметрах:








#States

Типы значения сотояний: Boolean, String, Number;

Состояние - внутреннее свойство представления, не связано с внешними свойствами (данными и моделями).

1. Дефолтные состояния связаны с основным поведением отображения: наведение, выбор, фокус, отключение и т.д.
2. Кастомные состояния могут быть связанными с сущностями бизнес логики или отражать состояние других частей, например моделей.

Изменение состояния может распространяется как вверх по дереву, так и в низ, в зависимости от типа состояния (View->ListView) или (ListView->View)
Что приведет к цепочке инвалидации.

Инициализация:

```html
<div .setStates='hover'>My simple button</div>
```
В данном случае мы активируем состояние hover и базовом классе TemplateView автоматически активируются внутренние слушатели mouseover/mouseout при добавлении в дом экземпляра.


Возможности состояний:

1. Могут использоваться в дочерних элементах для расширения дома в определенных состоянии

```html
<div .hover>
      <div id='hoverDiv' states='{state.hover}'>Элемент создается в DOM при наведении мышки</div>
</div>
```

Элемент "hoverDiv" автоматически добавится в DOM при наведении на родительский элемент

##Использование в аттрибутах
  # Использование в стилях
  ```html
  <div state.top='0' style="top:{state.top}px">При изменении состояния top изменяется отступ сверху</div>
  ```

  # Использование в классах
  ```html
  <div state.hover='false' class='button button-{state.hover}'></div>
  ```

  # Использование в любых аттрибутах
  ```html
  <input state.placeholder='Enter your name' placeholder='{state.placeholder} />
  ```

Элемент получит класс "button-hover" при наведении и потеряет класс при отведении мыши

3. Использование в выражениях

<div> // Включаем события по наведению
      {(state.hover?'Мышка наведена':'Мышка отведена')} ... Состояние наведения - {state.hover} (отобразит true при наведении, false при отведении мышки)
      // Формирует текст с помощью выражений
</div>

<div state.selected="{data.selected}" class="component component-{state.selected}">Данный компонент будет иметь класс "component-selected", в случае когда данные контекста компонента будут установлены, и класс автоматически пропадет, в случае если данные будут удалены.</div>


4. stateHandlers - Включение автоматических обработчиков событий

<div .stateHandlers="hover,selected,focused"></div>

Для компонентов можно выключать и выключать события, в том числе и при композиции
<div>
  ...
  <ft.Button .stateHandler="hover">Кнопка подсвечивается, установка состояния selected отсутствует при клике</ft.Button>
  <ft.Button>Кнопка имеющая все обработчики (hover,selected,focused)</div>
</div>




##UI
Базовый набор элементов отображения, которые реализуют концепцию виртуального (shadow) dom.





