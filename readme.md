#FMVC


В сегодняшнем мире существует большое количество фреймверков,
позволяющих разработчикам реализовывать сложные веб приложения с минимальными усилиями.


#*AngularJS* - любимый многими фреймверк от Google,
предоставляющий декларативный подход к описанию шаблонов и возможность просто управлять данными с помощью пространств.
Плюсы:
полноценный фреймверк, обширный АПИ дает все необходимые инструменты для программиста,
декларативный подход и двунаправленное упрощает создание простых приложений и компонентов,
удобное использование JQuery плагинов в системе Angular.

К недостаткам (версии 1.x) можно отнести тяжелый рендеринг при изменении данных (клиентская производительность),
объемную доменную логику в API директив, при создании выражений вынесение бизнес логики в шаблоны.

#*ReactJS* - молодой и захватывающий популярность фреймверк от Facebook,
дающий возможность быстро и эффективно создавать компоненты отображения данных.

Плюсы:
Изоморфность,
Shadow dom, хранение в виртуальном дереве компонентов, точечные изменения.
Собственная система трансляция событий, обработчики только в виртуальном дереве, нет необходимости подписок.
Очень простой в начале, фактически отсутсвует доменная логика, позволяет использовать javascript в шаблонах.
Функциональный подход, внутренне и внешнее состояние компонента.
Использование последних новшесты ES6,
Компоненты: material design и другие.

Минусы ReactJS -
Отвечает только за отображение, для всего остального потребуются сторнние дополнительные библиотеки:
Для создания бизнес логики и взаимодействия компонентов - Flux, Redux; для роутинга, для взаимодействия с сервером,
а также сложные компоненты UI.

##Введение FMVC

Fastmvc - *Фреймверк, написанный на TypeScript, скомплированный в JavaScript,
реализующий модель MVC(c элементами VM) для взаимодействия данных их отображения.

Нацелен на использования в рамках вебкомпонентов и одностраничных приложений.*

Зависимости: underscore.js.

*Facade* - фасад приложения, объединяющий компоненты модели (данные, наборы данных) в единое пространство,
а также медиаторов, которые отвечают за создание элементов представления и связывание отображения с моделями и фасадом.

*Model* - в простейшем приближении это контейнер данных, которые отслеживает изменения в данных и оповещает подписчиков об изменениях.

*Mediator* - создает и связывает представления с соотвествующими моделями и фасадом.

*View* - представления, реализующие или V концепцию - события транслируются по дереву комонентов в ближайший медиатор и MVVM концепцию - события напрямую транслируются в модель.
Отображения могут быть связаны с моделью, в данном случае создадутся необходимые связи с моделью и компонент будет

##Fast templates

*Позволяют реализовать паттерн "PVM"*
Presentation - обработка входящих данных и их адоптация, например l18n, для представленя
VM - прямой биндинг изменений представлений в модели, через систему обработчиков событий

*Состояние*
Имеют внутреннее состояния (states), на основе которых происходит их рендеринг

*Внешние данные*
Работа как с чистыми данными, так и с моделями, для которых отслеживаются изменения - однонаправленный биндинг
Возможность использовать двусторонний биндинг.
Шаблоны отслеживают изменения используемых полей объектов, и при их изменении, обновляют точечно узлы DOM.

*Система выражений и деклараций*
Возможность описывать в шаблонах связи с данными и состояниями, использовать JavaScript выражения.

*Shadow dom*
Темплейты имеют shadow dom, все применяемые изменения точные, с минимальными прерисовками

*Собственная система диспетчеризации событий*
События браузера транслируются во внутренние события, которые распространяются по Shadow Dom дереву.
Фактически внутри стоит один обработчик на рутовом объекте (window)

*Расширенная система работы с классами элемента внутри шаблона*

*Поддержка и инкапсуляция стилей компонентов*

*Поддержка словарей*

Шаблоны описываются в html подобном виде и пробразуются в JavaScript объекты, наследующие TemplateView.

```html
<div
      class='button button-{state.selected} button-{state.disabled}'
      onclick='myEvent'
      style="top:{top}px;left:{left}px;"
      >{data}
</div>
```

Описание шаблона


#States

Типы значения сотояний: Boolean, String, Number;

Состояние - внутреннее свойство представления, не связано с внешними свойствами (данными и моделями).

1. Дефолтные состояния связаны с основным поведением отображения: наведение, выбор, фокус, отключение и т.д.
2. Кастомные состояния могут быть связанными с сущностями бизнес логики или отражать состояние других частей, например моделей.

Изменение состояния может распространяется как вверх по дереву, так и в низ, в зависимости от типа состояния (View->ListView) или (ListView->View)
Что приведет к цепочке инвалидации.

Инициализация:

```html
<div .setStates='hover'>My simple button</div>
```
В данном случае мы активируем состояние hover и базовом классе TemplateView автоматически активируются внутренние слушатели mouseover/mouseout при добавлении в дом экземпляра.


Возможности состояний:

1. Могут использоваться в дочерних элементах для расширения дома в определенных состоянии

```html
<div .hover>
      <div id='hoverDiv' states='{state.hover}'>Элемент создается в DOM при наведении мышки</div>
</div>
```

Элемент "hoverDiv" автоматически добавится в DOM при наведении на родительский элемент

##Использование в аттрибутах
  # Использование в стилях
  <div state.top='0' style="top:{state.top}px">При изменении состояния top изменяется отступ сверху</div>

  # Использование в классах
  <div state.hover='false' class='button button-{state.hover}'></div>

  # Использование в любых аттрибутах
  <input state.placeholder='Enter your name' placeholder='{state.placeholder} />


Элемент получит класс "button-hover" при наведении и потеряет класс при отведении мыши

3. Использование в выражениях
<div state.hover>
      {(state.hover?'Мышка наведена':'Мышка отведена')} ... Состояние наведения - {state.hover}
</div>




@todo


# Custom states

Кастомные соостояния - кастомные состояния для отображения

Описание состояния
<f:state name="custom" value="0" type="int" />


@todo


##UI
Базовый набор элементов отображения, которые реализуют концепцию виртуального (shadow) dom.





